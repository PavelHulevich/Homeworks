"""
Принцип "открыто-закрыто" (OCP) для объектно-ориентированного проектирования означает, что:
Программные объекты (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.
В области разработки программного обеспечения элемент может быть открыт для расширения и закрыт для модификации.
Это означает, что вы или члены вашей команды должны иметь возможность добавлять новые функциональные возможности в
существующую программную систему без изменения существующего кода.

Если вы хотите добавить новую функциональность в свой существующий код и вам приходится модифицировать его перед
добавлением новой функциональности, значит, вы не следуете принципу "открыто-закрыто".

Почему вы должны использовать принцип "Открыто-закрыто"?
Вот несколько причин, по которым вам следует использовать принцип "открыто-закрыто":
    • Вам не нужно изобретать велосипед заново: как гласит принцип, код, над которым работаете вы и ваша команда, закрыт
      для расширения. Это означает, что если вы следуете принципу "открыто-закрыто", вам не нужно изобретать велосипед
      (и все перестраивать), когда вы хотите добавить новые функции.
    • Вы сосредотачиваетесь на том, что необходимо: как указано в OCP, ваш код закрыт для модификации. Это означает,
      что вы можете добавлять новые функции, не выполняя слишком большого редактирования существующего кода, или вообще
      ничего не редактировать. Это может помочь вам и членам вашей команды сосредоточиться на том, что необходимо, когда
      придет время внедрять новые функции.
    • Вы можете избежать ошибок: поскольку вам не нужно редактировать существующий код перед добавлением новых функций,
      вы можете избежать появления ненужных ошибок.
    • Ваш код более удобен в обслуживании, тестировании и гибок: следование OCP сделает вашу кодовую базу слабо
      связанной. Благодаря этому код становится более гибким и поддерживаемым. И если вы хотите, вы можете успешно
      протестировать каждый класс в модульном режиме.

"""
from abc import ABC, abstractmethod
from math import pi


"""
В этом коде вы полностью реорганизовали класс Shape, превратив его в абстрактный базовый класс (ABC). Этот класс 
предоставляет необходимый интерфейс (API) для любой формы, которую вы хотели бы определить. Этот интерфейс состоит из 
атрибута .shape_type и метода .calculate_area(), который вы должны переопределить во всех подклассах.
Это обновление закрывает класс для изменений. Теперь вы можете добавлять новые фигуры в дизайн вашего класса без 
необходимости изменять форму. В каждом случае вам придется реализовать необходимый интерфейс, который также делает ваши
 классы полиморфными.
"""


class Shape(ABC):
    def __init__(self, shape_type):
        self.shape_type = shape_type

    @abstractmethod
    def calculate_area(self):
        pass


class Circle(Shape):
    def __init__(self, radius):
        super().__init__("circle")
        self.radius = radius

    def calculate_area(self):
        return pi * self.radius**2


class Rectangle(Shape):
    def __init__(self, width, height):
        super().__init__("rectangle")
        self.width = width
        self.height = height

    def calculate_area(self):
        return self.width * self.height


class Square(Shape):
    def __init__(self, side):
        super().__init__("square")
        self.side = side

    def calculate_area(self):
        return self.side**2
