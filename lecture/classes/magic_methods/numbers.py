"""
Числовые магические методы делятся на несколько групп:
    унарные операторы,
    обычные арифметические,
    отражённые арифметические операторы,
    составные присваивания,
    преобразования типов.


Унарные операторы
__neg__(self) — определяет поведение для отрицания (-a)
__pos__(self) — определяет поведение для унарного плюса (+a)
__abs__(self) — определяет поведение для встроенной функции abs(...)
__invert__(self) — определяет поведение для инвертирования оператором ~


Обычные арифметические операторы
__add__(self, other) — сложение, оператор +
__sub__(self, other) — вычитание, оператор -
__mul__(self, other) — умножение, оператор *
__matmul__(self, other) — умножение матриц, оператор @
__truediv__(self, other) — деление, оператор /
__floordiv__(self, other) — целочисленное деление, оператор //
__mod__(self, other) — остаток от деления, оператор %
__divmod__(self, other) — деление с остатком, определяет поведение для встроенной функции divmod(...)
__pow__(self, other[, modulo]) — возведение в степень, оператор **
__lshift__(self, other) — двоичный сдвиг влево, оператор <<
__rshift__(self, other) — двоичный сдвиг вправо, оператор >>
__and__(self, other) — двоичное И, оператор &
__xor__(self, other) — исключающее ИЛИ, оператор ^
__or__(self, other) — двоичное ИЛИ, оператор |


Отражённые арифметические операторы
Если в обычной арифметике между объектами a и b, объектом, который мы изменяем, является a,
и объектом, с которым мы работаем, является b, то в отражённой арифметике наоборот — b является изменяемым,
a — объектом, с которым мы работаем, и который передается в качестве аргумента. Например:
# Сложение, используется обычная арифметика и метод __add__ в объекте left:
left + right
# Сложение, используется отражённая арифметика и метод __radd__ в объекте left:
right + left
Список методов похож на тот, что используется в обычной арифметике, за исключением того,
 что добавляется префикс «r» ко всем методам:
__radd__(self, other) — сложение, оператор +
__rsub__(self, other) — вычитание, оператор -
__rmul__(self, other) — умножение, оператор *
__rmatmul__(self, other) — умножение матриц, оператор @
__rtruediv__(self, other) — деление, оператор /
__rfloordiv__(self, other) — целочисленное деление, оператор //
__rmod__(self, other) — остаток от деления, оператор %
__rdivmod__(self, other) — деление с остатком
__rpow__(self, other[, modulo]) — возведение в степень, оператор **
__rlshift__(self, other) — двоичный сдвиг влево, оператор <<
__rrshift__(self, other) — двоичный сдвиг вправо, оператор >>
__rand__(self, other) — двоичное И, оператор &
__rxor__(self, other) — исключающее ИЛИ, оператор ^
__ror__(self, other) — двоичное ИЛИ, оператор |


Составное присваивание
Эти методы — комбинация «обычного» оператора и присваивания. В
озвращают тот же тип объекта, который будет присвоен переменной слева. Например:
x = 3
x += 2 # другими словами x = x + 2

__iadd__(self, other) — сложение с присваиванием, оператор +=
__isub__(self, other) — вычитание с присваиванием, оператор -=
__imul__(self, other) — умножение с присваиванием, оператор *=
__imatmul__(self, other) — умножение матриц с присваиванием, оператор @=
__itruediv__(self, other) — деление с присваиванием, оператор /=
__ifloordiv__(self, other) — целочисленное деление с присваиванием, оператор //=
__imod__(self, other) — остаток от деления с присваиванием, оператор %=
__ipow__(self, other[, modulo]) — возведение в степень с присваиванием, оператор **=
__ilshift__(self, other) — двоичный сдвиг влево с присваиванием, оператор <<=
__irshift__(self, other) — двоичный сдвиг вправо с присваиванием, оператор >>=
__iand__(self, other) — двоичное И с присваиванием, оператор &=
__ixor__(self, other) — исключающее ИЛИ с присваиванием, оператор ^=
__ior__(self, other) — двоичное ИЛИ с присваиванием, оператор |=


Преобразования типов
Помимо всего прочего, в Python множество методов, которые позволяют переопределять поведение встроенных функций
преобразования типов, таких как int(...), float(...) и т.д.
__complex__(self) — преобразование типа в комплексное число
__int__(self) — преобразование типа к int
__float__(self) — преобразование типа к float
__index__(self) — преобразование типа к int, когда объект используется в срезах (выражения вида [start:stop:step])
__round__(self[, ndigits]) — округление числа с помощью функции round(...)
__trunc__(self) — вызывается методом math.trunc(...)
__floor__(self) — вызывается методом math.floor(...)
__ceil__(self) — вызывается методом math.ceil(...)

"""


class Test:

    def __init__(self):
        self.a = 100

    def __pos__(self):
        print("Method __pos__ called")
        self.a -= 1
        return self.a

    def __add__(self, other):
        print("Method __add__ called")
        self.a -= other
        return self.a


test = Test()
print(test.a)
print(+test)
print(test + 10)
