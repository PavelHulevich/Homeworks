#  Передача аргументов — способ отправки функциям объектов как входных данных.
#  Аргументы (называемые также параметрами) присваиваются именам в функции, за исключением изменяемых типов данных.
#  Неизменяемые аргументы фактически передаются “по значению”.
#
#  Объекты, подобные целым числам и строкам, передаются по ссылке на объекты, а не путем копирования,
#  но из-за того, что модифицировать на месте неизменяемые объекты невозможно, эффект во многом похож на создание копий.
#
#  Изменяемые аргументы фактически передаются “по указателю”.
#  Объекты вроде списков и словарей также передаются по ссылке на объекты


#  переменной c присваивается объект 88 в момент, когда функция вызывается.
#  Но c существует только внутри вызванной функции.
#
#  Изменение а внутри функции никак не воздействует на место, где функция вызывалась;
#  оно просто переустанавливает локальную перемененную а в совершенно другой объект.
def f(c):
    c = 99


b = 88
f(b)
print(b)


def f(c):
    c = 99
    return c


b = 88
f(b)
print(b)

b = f(b)
print(b)


#  Когда аргументам передаются изменяемые объекты, подобные спискам и словарям, мы должны осознавать,
#  что изменения на месте таких объектов могут продолжить свое существование после завершения функции,
#  а потому оказывать воздействие на вызывающий код
def changer(c, d):
    c = 2
    d[0] = 'spam'


x = 1
L = [1, 2]
print(x, L)
changer(x, L)
print(x, L)


def changer(c, d):
    c = 2
    s = d.copy()
    s[0] = 'spam'

    return c, s

print('-----------------------')
x = 1
L = [1, 2]
print(x, L)
y, z = changer(x, L)
print(x, L)
print(y, z)


print('-----------------------')
print('Обязательные аргументы')
#
def pmin(a, b):
    if a < b:
        print(a)
    else:
        print(b)

c = 1
d = 2
pmin(c, d)

try:
    pmin(c, d, d)
except TypeError:
    pass


#  Аргументы – ключевые слова
def person(name, age):
    print('Меня зовут ', name, ', мне ', age, ' лет.', sep='')


person(name='Ivan', age=20)
person(age=20, name='Ivan')


#  Аргументы по умолчанию
def inc(a, b=1):
    print(a + b)

inc(5)

inc(5, 2)


print('-----------------')

#  Произвольное количество аргументов
def msum(*a):
    s = 0
    for i in a:
        s += i
    print(s)


msum(5, 2, 6, 7, 8, 9)


#  произвольное число именованных аргументов
def func(**a):
    return a

print(func(a=1, b=2, c=3, d=4))


#  Специальный синтаксис *args в определениях функций в Python используется для передачи функции переменного
#  числа аргументов. По соглашению, он часто используется со словом args.
#  Специальный синтаксис **kwargs в определениях функций в Python используется для передачи списка аргументов
#  переменной длины с ключевыми словами.

def myFun(*args, **kwargs):
    print("args: ", args)
    print("kwargs: ", kwargs)


myFun('Python', 'is', 'language', first="Python", mid="is", last="language")


print('---------------------')

def myFun(arg1, arg2, arg3):
    print("arg1:", arg1)
    print("arg2:", arg2)
    print("arg3:", arg3)


myFun("Python", "is", "language")

args = ("Python", "is", "language")
myFun(*args)

print('---------------------')


myFun(arg1="Python", arg2="is", arg3="language")

kwargs = {"arg1": "Python", "arg2": "is", "arg3": "language"}
myFun(**kwargs)


print('==============')

#  Аргументы с передачей только по ключевым словам Python З.Х
#  Синтаксически аргументы с передачей только по ключевым словам записываются как именованные аргументы,
#  которые могут появляться после конструкции ★ аргументы в списке аргументов.
#  Значения для таких аргументов должны передаваться в вызове с использованием синтаксиса ключевых аргументов.
def kwonly(a, *b, c):
    print(a, b, c)


kwonly(1, 2, c=3)
kwonly(a=1, c=3)
#kwonly(1, 2, 3)


print('==============')
#  аргумент а снова может передаваться по позиции или по имени, но аргументы b и с обязаны передаваться по
#  ключевому слову, и никакие добавочные позиционные аргументы не разрешены
def kwonly(a, *, b, c):
    print(a, b, c)


kwonly(1, c=3, b=2)
kwonly(c=3, b=2, a=1)
#kwonly(1, 2, 3)
#kwonly(1)


print('==============')
#  В этом коде а может передаваться по имени или по позиции, а b и с являются необязательными,
#  но должны передаваться по ключевым словам, если присутствуют
def kwonly(a, *, b='spam', c='ham'):
    print(a, b, c)


kwonly(1)
kwonly(1, c=3)
kwonly(a=1)
kwonly(c=3, b=2, a=1)
try:
    kwonly(1, 2)
except TypeError:
    pass


#  напишите функцию, которая способна находить минимальное значение в произвольном наборе аргументов числовых типов
#  данных. То есть функция обязана принимать ноль и более аргументов — столько, сколько передается.
def min(*a):
    b = list(a)
    b.sort()
    return b[0]


print(min(1,2,3))
print(min(1))
print(min(1,2,3,4,5,6,7))


#  другой вариант
def min(first, *a):
    for arg in a:
        if arg < first:
            first = arg

    return first


print(min(1,2,3))
print(min(1))
print(min(1,2,3,4,5,6,7))


def min(first, second, third, *a):
    for arg in a:
        if arg < first:
            first = arg

    return first


print(min(1,2,3))
print(min(1,2,3,4,5,6,7))
