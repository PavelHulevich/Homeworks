#  функция это способ группирования набора операторов, позволяющая выполнять их более одного раза в программе.
#  Функции способны вычислять результирующее значение и также дают возможность указывать параметры,
#  которые служат входными данными функции и могут отличаться при каждом выполнении кода.

#  Две основные роли функций во время разработки:
#   1. Доведение до максимума многократного использования кода и сведение к минимуму избыточности - Как и в большинстве
#      языков программирования, функции Python являются простейшим способом упаковки логики,
#      которая применяется более чем в одном месте и более одного раза.
#
#   2. Процедурная декомпозиция - Функции также предлагают инструмент для разбиения систем на части.
#      У каждой части должна быть определенна роль.

#  Правила создания функций:
#   1. Для объявления функции в Python используется ключевое слово def.
#   2. Название функции должно начинаться с символа латинского алфавита в любом регистре или нижнего подчеркивания.
#   3. В каждой функции есть двоеточие и отступ, после которого записывается сам код программы.
#   4. Зарезервированные ключевые слова не могут использоваться в качестве названия функции.
#   5. Функция может содержать несколько параметров или не иметь их совсем.

#  Синтаксис
# .  def имя_функции(параметры):


def function_name():
    ...


def function_name():
    #  логика функции
    return None


def function_name():
    # логика функции
    result = 1
    return result  # возврат значения


#  Для вызова функции следует ввести ее имя и добавить скобки, а в них уже указать фактические аргументы.
def my_fun():
    x = 22 ** 5
    return x

#  1. Вызов функции
my_fun()
#  2. Вызов функции и присвоение результат переменной
p = my_fun()
#  3. Вызов функции и вывод результат в консоль
print(my_fun())


#  Оператор def в Python является исполняемым оператором: при выполнении он создает новый объект функции
#  и присваивает его имени. Поскольку def — оператор, он может появляться везде, где допускается оператор,
#  даже внутри других операторов. Например, хотя операторы def обычно выполняются, когда включающий их модуль
#  импортируется, также совершенно законно вкладывать def внутрь оператора if
test = 1
if test:
    def func():
        print('11111')
else:
    def func():
        ...

func()


#  функции Python не нуждаются в полном определении перед запуском программы.
#  код внутри операторов def не выполняется до вызова функций.
def func():
    print(1)
    pass


def func2():
    print(2)
    pass


func()


#  Из-за того, что определение функций происходит во время выполнения, в имени функции нет ничего особенного.
#  Важен объект, на который оно ссылается
othername = func2
othername()


#  в Python, функции — это просто объекты; они явно записываются в память во время выполнения программы.
#  На самом деле кроме вызовов функции позволяют присоединять произвольные атрибуты для регистрации информации
def func3():
    print(3)

#  Не делайте так
func3()
func3.attr = 'attr'
func3.another_attr = 'another_attr'


print(func3.attr)
print(func3.another_attr)


#  в Python функции — это объекты первого класса, у них есть те же свойства и методы, что и обычных объектов.
#  Особенности функций как объектов первого класса:
#     1. Функции можно присваивать переменным.
#     2. Функцию можно вернуть из функции.
#     3. Функцию можно передать в качестве аргумента при вызове другой функции.

def hello(name):
    print(f"Hello, {name}!")

#  Функции можно присваивать переменным
greeting_function = hello
greeting_function("world")


#  пример с передачей функции в качестве аргумента другой функции
def apply_function(numbers, function):
    results = []
    for number in numbers:
        result = function(number)
        results.append(result)
    return results


def square(number):
    return number ** 2


numbers = [1, 2, 3, 4, 5]
squared_numbers = apply_function(numbers, square)
print(squared_numbers)


#  Объекты первого класса также позволяют возвращать функции из другой функции
def make_multiplier(n):
    def multiplier(x):
        return x * n
    return multiplier


times_2 = make_multiplier(2)  # 2 остается в контексте функции до следующего вызова с другим параметром
times_3 = make_multiplier(3)  # 3 остается в контексте функции до следующего вызова с другим параметром

print(times_2(5))
print(times_3(5))

#  еще можно делать так:
print(make_multiplier(2)(5))
print(make_multiplier(3)(5))


#  если не делаем
def make_multiplier(n, x):
    return x * n


print(make_multiplier(2, 5))
print(make_multiplier(3, 5))
print(make_multiplier(2, 6))


#  лаконичнее
print(times_2(5))
print(times_3(5))


#  Lambda-функция – это безымянная функция с произвольным числом аргументов и вычисляющая одно выражение.
#  Lambda-функцию можно присвоить какой-либо переменной и в дальнейшем использовать ее в качестве имени функции
f = lambda x: x**2
print(f(5))
print((lambda x: x**2)(5))


print('-------------------')


#  Полиморфизм в языках программирования и теории типов — способность функции обрабатывать данные разных типов
def times(х, у):
    return х * у


print(times(2, 4))
print(times(3.14, 4))
print(times("Ni", 4))


#  если передаем аргументы типов, не поддерживающих оператор *
def some_func():
    try:
        times('sdf', 3.14)
    except TypeError:
        print("TypeError")

some_func()



class int:

    def __init__(self, a):
        self.a = a

    def __mul__(self, other):
        return self.a * other


class str:

    def __init__(self, a):
        self.a = a

    def __mul__(self, other):
        new_str = ''

        for i in range(other):
            new_str += self.a

        return new_str


"""
Одна функция внутри другой — это вложенные функции. 
Создавать вложенные функции можно с помощью того же ключевого слова def. 
После создания функции нужно вызвать как внешнюю, так и внутреннюю.
"""


def out_fun():
    print("Hi I'm outer function")

    def in_fun():
        print("Hi I'm inner function")

    in_fun()

out_fun()

"""
Здесь функция in_fun() определена внутри out_fun(). Для вызова in_fun() нужно сперва вызвать out_fun(). 
После этого out_fun() начнет выполняться, что приведет к вызову in_fun().
Внутренняя функция не будет выполняться, если не вызвать внешнюю.
"""


"""
Программа для вывода результата сложения двух чисел с помощью вложенных функций в Python.
"""
def fun1():
    a = 6  # локальная переменная внешней функции

    def fun2(b):
        a = 4  # локальная переменная внутренней функции
        print("Сумма внутренней функции", a + b)

    print("Значение переменной a", a)
    fun2(4)


fun1()  # 8
